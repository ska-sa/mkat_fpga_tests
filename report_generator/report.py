"""The reports generated by AQF is defined in this module."""

import datetime
import json
import zlib
import os
import re
import itertools

from report_generator.rest_producer import ReStProducer


class Report(object):

    """
    Create all the various reports.

    The corelation with the CORE data is also done in the class.

    """

    def __init__(self, data=None, system_data=None, acceptance_report=None):
        # See update_status_strings method.
        self.UNKNOWN = 'unknown'
        self.WAIVED = 'waived'
        self.PASS = 'passed'
        self.SKIP = 'skipped'
        self.TBD = 'tbd'
        self.FAIL = 'failed'
        self.ERROR = 'error'
        self.base_dir = ''

        if data:
            self.test_data = data
        else:
            self.test_data = {}

        if system_data:
            # system_data could be a filename.
            self.system_data = system_data
        else:
            self.system_data = {}

        self.docproducer = ReStProducer()
        self.requirements = {}
        self._cache_requirements_from_tests = {}
        self.core_meta = {}
        self.document_lookup = {}
        if acceptance_report:
            self.acceptance_report = True
        else:
            self.acceptance_report = False

    def clear(self):
        """Clear the current report."""
        self.docproducer = ReStProducer()

    def as_list(self, report_type=None):
        """Return report as a list, each item in list is a line in report."""
        if not self.test_data['Meta'].get('end'):
            self.test_data['Meta']['end'] = str(datetime.datetime.utcnow())
        # Select the report type we want to output.
        {'summary': self._rst_summary,
         'tests': self._rst_tests,
         'system': self._rst_system,
         'table': self._rst_table,
         'requirements': self._rst_requirement_list,
         'core': self._rst_core,
         'procedure': self._rst_procedure,
         'timescale': self._rst_timescale,
         'not_vr_procedure': (lambda v: self._rst_procedure(v, False)),
         'not_vr_table': (lambda v: self._rst_table(v, filter_name='not_vr')),
         'vr_table': (lambda v: self._rst_table(v, filter_name='vr')),
         }.get(report_type, self._rst_summary)(self.docproducer)
        return self.docproducer.output

    def as_text(self, report_type=None):
        """Return report as one string."""
        out_text = ''
        for line in self.as_list(report_type):
            out_text += line + "\n"
        return out_text

    def get_timescales(self):
        """Get the names of the timescales.

        :return: List. Sorted list of timescales.

        """

        # return sorted(set([self.requirements[r]['timescale']
        #                    for r in self.requirements
        #                    if self.requirements[r].get('timescale')] +
        #               ['Timescale Unlinked']))
        # Uncomment above to have tests separated out by timescale
        return ['Timescale Unlinked']

    def write_rst_cbf_files(self, base_dir, build_dir, katreport_dir, prefix):
        """Generate a set of reports for CBF."""
        self.base_dir = base_dir
        self.build_dir = build_dir
        self.katreport_dir = katreport_dir
        for test_req in self._requirements_from_tests():
            if test_req not in self.requirements:
                # Create a fake Core entry.
                self.requirements[test_req] = \
                    {'definition': 'VerificationRequirement',
                     'category-list': ["1200 CBF"],
                     'method': 'test'}
        self.generate_include_documents(base_dir)
        timescales = self.get_timescales()

        scheme = 'acceptance' if self.acceptance_report else 'qualification'
        demo = False
        number = 0
        documents = ['CBF %s Summary' % scheme.capitalize(),
                     'System Information']
        for timescale in nsort(timescales):
            for demo in [False, True]: # for Testing and Demonstration
                for procedure in [True, False]: # For Procedure and Results

                    self.clear()
                    number += 1
                    title = self.generate_cbf_report(
                        base_dir, timescale, scheme, demo, procedure,
                        number='AQF.{0}'.format(number))
                    if not title:
                        number -= 1
                        continue
                    documents.append(title)
                    filename = os.path.join(base_dir, "%s.rst" %
                                            title.lower().replace(' ', '_'))
                    with open(filename, 'w') as fh:
                        for line in self.docproducer.output:
                            if isinstance(line, unicode):
                                line = line.encode('utf-8')
                            fh.write(line + '\n')
        if documents:
            filename = os.path.join(base_dir, 'doc_list.inc')
            with open(filename, 'w') as fh:
                for line in documents:
                    fh.write(" * {0}\n".format(
                        self.docproducer.add_link(line)))
                # Add katreport.json and output.log links
                fh.write(" * Test results:  :download:`katreport.json <{0}/katreport.json>`\n".format(
                        self.katreport_dir))
                fh.write(" * Test output log:  :download:`output.log <{0}/output.log>`\n".format(
                        self.katreport_dir))
                fh.write(" * CORE export:  `katreport_core.html <{0}/katreport_core.html>`\n".format(
                        self.katreport_dir))

        self.clear()
        dp = self.docproducer
        filename = os.path.join(base_dir, "summary_info.inc")
        start = self.test_data.get("Meta", {}).get("start", "Unknown")
        end = self.test_data.get("Meta", {}).get("end", "Unknown")
        site_type = self.test_data.get("Meta", {}).get("sitename", "Unknown")

        dp.add_line(":Test run: from %s until %s" % (start, end))
        dp.add_line(':Build directory: %s' % dp.add_link(build_dir))
        dp.add_line(":Site Type: '%s'" % site_type)
        dp.add_line(':CORE Exported on: %s' % (self.core_meta.get(
            'export', {}).get('time-stamp', '')))

        with open(filename, 'w') as fh:
            for line in self.docproducer.output:
                fh.write(line + '\n')
        self.clear()
        self._rst_summary()
        filename = os.path.join(base_dir, "katreport_summary.rst")
        with open(filename, 'w') as fh:
            for line in self.docproducer.output:
                fh.write(line + '\n')
        self.clear()
        self.write_report_system_info(base_dir)

    def _include_in_test_doc(self, ver_req_id, acceptance_report):
        """
        Check if a requirement is linked to a test that should be included for Testing docs:
        If acceptance_report then:
            all auto + demo tests that are decorated with site_acceptance + site_tests
        else
            All auto_tests + demo_tests + site_tests
            (demo and site is required to generate the full demonstration procedure)
        """
        return True
        # requirements = self._requirements_from_tests()
        # ver_requirement = requirements.get(ver_req_id, {})
        # tests = ver_requirement.get('tests', [])
        # for test in tests:
        #     # ver_req_id == 'auto' is default for tests
        #     # not tagged with VR.xx.AUTO.nn or VR.xx.DEMO.nn or VR.xx.SITE.nn
        #     auto_test = self.test_data[test].get('aqf_auto_test', ver_req_id == 'auto')
        #     demo_test = self.test_data[test].get('aqf_demo_test', False)
        #     site_test = self.test_data[test].get('aqf_site_test', False)
        #     site_acceptance = self.test_data[test].get('aqf_site_acceptance', False)
        #     if acceptance_report:
        #         # For Acceptance Testing:
        #         in_test_doc = site_test or site_acceptance
        #     else:
        #         # For Qualification Testing:
        #         in_test_doc = not site_test
        #     if in_test_doc:
        #         return True

    def _include_in_demo_doc(self, ver_req_id, acceptance_report):
        """
        Check if a requirement is linked to a test that should be included for Demonstration docs:
        If acceptance_report then:
            all demo tests that are decorated with site_acceptance + site_tests
        else
            All auto_tests + demo_tests + site_tests
            (demo and site is required to generate the full demonstration procedure)
        """
        requirements = self._requirements_from_tests()
        ver_requirement = requirements.get(ver_req_id, {})
        tests = ver_requirement.get('tests', [])
        for test in tests:
            demo_test = self.test_data[test].get('aqf_demo_test', False)
            site_test = self.test_data[test].get('aqf_site_test', False)
            site_acceptance = self.test_data[test].get('aqf_site_acceptance', False)
            if acceptance_report:
                # For Acceptance Demonstration:
                in_demo_doc = site_test or (demo_test and site_acceptance)
            else:
                # For Qualification Demonstration:
                in_demo_doc = not site_test and demo_test
            if in_demo_doc:
                return True

    def generate_cbf_report(self, base_dir, timescale, scheme,
                            demo=False, procedure=True, number=None):
        """Generate the cbf reports.

        :param timescale: String. Timescale for the report.
        :param scheme: String. Scheme for the report.
        :param demo: Boolean. If this reports on the demo.
        :param procedure: Boolean. If this is a test procedure or test result.
        :return: String. The title of the report.

        """
        demo_doc = True if demo else False
        test_doc = not demo_doc
        procedure_doc = True if procedure else False
        results_doc = not procedure_doc
        demo_test_title = 'Demonstration' if demo else 'Testing'
        proc_result_title = 'Procedure' if procedure else 'Results'
        title_l = ['CBF', timescale.title(), scheme.title()]
        title_l.append(demo_test_title)
        title_l.append(proc_result_title)
        title = ' '.join(title_l)
        # This produces "CBF Timescale N Demonstration/Testing Procedure/Results"

        if number:
            key = title.lower()
            self.document_lookup[key] = number + ' ' + title
            title = self.document_lookup[key]
            # self.docproducer.add_heading('chapter', number + ' ' + title,
            #                             anchor=True)
        self.docproducer.add_heading('chapter', title, anchor=True)

        # Include stats and tables.
        inc_title = "CBF %s %s %s %s Summary" % \
                    (timescale, scheme, demo_test_title, proc_result_title)
        inc_filename = inc_title.lower().replace(" ", "_") + ".inc"
        self.docproducer.add_include(inc_filename)

        inc_title = "CBF %s %s %s %s" % \
                    (timescale, scheme, demo_test_title, proc_result_title)
        inc_filename = inc_title.lower().replace(" ", "_") + "_table.inc"
        self.docproducer.add_include(inc_filename)

        # Generate the list of requirements to include
        req_list = []
        for item in self.requirements:
            requirement = self.requirements[item]
            # Build up a list of verification requirements.
            if (requirement.get('definition') not in ('VerificationRequirement'
                                                      'TestProcedure')):
                # Only verification requirements.
                continue
            if (requirement.get('timescale',
                                'Timescale Unlinked') != timescale):
                # Only for the selected timescale.
                continue

            if not (item.startswith('TP.C.') or
                    item.startswith('R.C.')):
                continue
            if self.acceptance_report:
                if not self.is_acceptance(item):
                    continue
            if False:
                # Previous selection criteria
                method = requirement.get('method', "".join(item.split(".")[-2:-1]))
                is_demo = method.lower().strip() not in ['test', 'auto']
                if (is_demo != demo):
                    # If this is a demo report we only want demo's
                    continue
            else:
                # Don't use the method here - not too sure if those are reliable
                ver_req_id = requirement.get('kat_id', 'auto')
                #print item,"===",ver_req_id,"==================================="
                #print requirement
                if demo_doc and not self._include_in_demo_doc(ver_req_id, self.acceptance_report):
                    continue
                elif test_doc and not self._include_in_test_doc(ver_req_id, self.acceptance_report):
                    continue
                #print "--include--", ver_req_id, "demo_doc", demo_doc, "test_doc", test_doc
            req_list.append(item)

        if not req_list:
            return

        demo_script = []
        count = 0
        for item in nsort(req_list):
            demo_script.append(('requirement', item))
            count += 1
            aqf_number = "{0}.{1}".format(number, count)
            # Ignore test procedures that were not tested for the text of the test report.
            if item not in self._requirements_from_tests():
                continue
            self.add_requirement(item, ['description', 'relationship'],
                                 title=inc_title,
                                 number=aqf_number)
            demo_script.append(('aqf_no', aqf_number))
            if procedure:
                self.add_requirement_procedure(item, demo_script)
            else:
                self.add_requirement_results(item)

        if demo and procedure:
            self.write_script(base_dir, timescale, scheme, demo_script)
        return title

    def write_script(self, base_dir, timescale, scheme, demo_script):
        """Create the script for the demo run."""
        demo_script.append(('requirement', u'VR.CM.DEMO.999999999'))
        filename = os.path.join(base_dir, 'demo_script_{0}_{1}.sh'.format(
            timescale, scheme).lower().replace(" ", '_'))
        fh = open(filename, 'w')
        fh.write("#! /bin/bash\n")
        check = {'step': '', 'checkbox': '',
                 'test': '', 'requirement': ''}
        fh.write("RUN=false\nSTART=$1\nEND=$2\n")
        fh.write('if [ -z "$START" ] ; then RUN=true; fi\n\n')
        old_req = ''
        tests = []
        for item in demo_script:
            # fh.write("# - %s\n" % str(item))
            name = item[0]
            check[name] = item[1]
            if not old_req and name == 'requirement':
                old_req = check[name]
            if name == 'test':
                test_path = check['test'].split(".")
                testfile = "{0}.py:{1}.{2}".format('/'.join(test_path[:-2]),
                                                   test_path[-2],
                                                   test_path[-1])
                if testfile not in tests:
                    tests.append(testfile)
            if old_req != check['requirement']:
                if not check['checkbox'] or not tests:
                    # Continue if the req has no tests or no checks.
                    tests = []
                    check['checkbox'] = ''
                    old_req = check['requirement']
                    continue
                fh.write('\n# %s\n' % str(check))

                fh.write('if [ "$START" == "{0}" ] ; then RUN=true; fi\n'.
                         format(old_req))
                # Fix this when test is done
                cmd = ["./run_test.py", "--demo"]
                fh.write('if $RUN ; then\n')
                fh.write('\necho\necho ' + '[]' * 40 + '\necho\n')
                # fh.write('\n# %s\n' % check['checkbox'].get('msg', ''))
                fh.write('\necho %s - %s\n' % (check.get('aqf_no'), old_req))
                # Fix this when test is done
                fh.write(' '.join(cmd + tests))
                fh.write('\nfi\nif [ "$END" == "{0}" ] ; then exit; fi\n'
                         .format(old_req))
                old_req = check['requirement']
                tests = []
                check['checkbox'] = ''
        fh.write('\n')
        fh.close()
        os.chmod(filename, int(0755))

    def write_test_rst_file(self, base_dir, prefix):
        """Write files for each test group."""
        groups = {}
        for test_id in sorted(self.test_data.keys()):
            test = self.test_data[test_id]
            group = test.get('group', 'ungrouped').lower()
            if groups.get(group):
                groups[group].append(test_id)
            else:
                groups[group] = [test_id]

        for group in groups:
            if groups[group]:
                filename = os.path.join(base_dir, "%s_%s.rst" %
                                        (prefix, group))
                self.clear()
                self.docproducer.add_heading('chapter',
                                             'AQF Test Group: %s' % group)
                for test in groups[group]:
                    self._rst_show_test(self.docproducer, 1, test,
                                        self.test_data[test])
                with open(filename, 'w') as fh:
                    for line in self.docproducer.output:
                        fh.write(line + '\n')

    def load_core_requirements(self, requirements_file):
        """Read CORE requirements from a JSON file."""
        if requirements_file and os.path.isfile(requirements_file):
            with open(requirements_file, 'r') as fh:
                self.requirements = json.loads(fh.read())
        if self.requirements and "__Meta" in self.requirements:
            self.core_meta = self.requirements['__Meta']
            del(self.requirements['__Meta'])

    def load_test_results(self, data=None, filename=None):
        """
        Load new test data for report.

        Data can be given or the filename that contains a JSON document.

        """
        if data:
            self.test_data = data
        elif filename:
            with open(filename, 'r') as fh:
                self.test_data = json.loads(fh.read())
        else:
            raise Exception("No test data or test data file given.")

    def new(self):
        """
        Clear the docproducer and start a new report.

        Nesesary for when this class is instantiated once , but several reports
        needs to be produced.

        """
        self.docproducer = ReStProducer()

    def update_status_strings(self, unknown=None, passed=None, skipped=None,
                              tbd=None, failed=None, error=None):
        """Keep the status labels in sync over the classes."""
        if unknown:
            self.UNKNOWN = unknown
        if passed:
            self.PASS = passed
        if failed:
            self.FAIL = failed
        if error:
            self.ERROR = error
        if tbd:
            self.TBD = tbd
        if skipped:
            self.SKIP = skipped

    def write_to_file(self, filename, report_type=None):
        """Write report to a file."""
        with open(filename, 'w') as fh:
            for line in self.as_list(report_type):
                if isinstance(line, unicode):
                    line = line.encode('utf-8')
                fh.write(line + "\n")

    def prepare_dict(self, data, path):
        t_data = data
        for item in path:
            if item not in t_data:
                t_data[item] = {}
            t_data = t_data[item]

    def sum_status(self, data):
        """Sum the statuses and total."""

        test_counts = {'total': 0}
        for test in data:
            test_counts['total'] = test_counts.get('total', 0) + 1
            status = data[test]
            test_counts[status] = test_counts.get(status, 0) + 1

        return test_counts

    def grouped_requirements(self, func=None):
        """Group requirements by timescale, scheme (qualification or acceptance), [optional: func]

        :return: Dict.

        """
        if func is None:
            func = lambda n: 1
        data = {}
        for item in self.requirements:
            requirement = self.requirements[item]
            definition = requirement.get('definition', 'CBF Verification Test')
            # Treat all things as being of unlinked timescale
            #timescale = requirement.get('timescale', 'Timescale Unlinked')
            timescale = 'Timescale Unlinked'
            if False:
                # is_demo = requirement.get('method') == 'Demonstration'
                method = requirement.get('method', "".join(item.split(".")[-2:-1]))
                is_demo = method.lower().strip() not in ['test', 'auto']
                if self.acceptance_report:
                    if not self.is_acceptance(item):
                        continue
            else:
                ver_req_id = requirement.get('kat_id', 'auto')
                is_demo = self._include_in_demo_doc(ver_req_id, self.acceptance_report)
                is_test = self._include_in_test_doc(ver_req_id, self.acceptance_report)
                if not is_demo and not is_test:
                    # This requirement is not included in this set
                    continue
            demo_test = 'Demonstration' if is_demo else 'Testing'
            self.prepare_dict(data, [timescale, definition, demo_test])
            data[timescale][definition][demo_test][item] = func(item)
        return data

    def status_of_requirements(self, req, demo=False):
        rft = self._requirements_from_tests()
        status = rft.get(req, {}).get('status', self.UNKNOWN).upper()
        if demo and status not in ['WAIVED']:
            # For demo's we just say Exist, Not Implemented or
            # say that it is WAIVED.
            return 'Exists' if req in rft else 'Not Implemented'
        else:
            return status

    def _rst_summary(self, docproducer=None):
        """Generate the summary report."""
        if docproducer is None:
            docproducer = self.docproducer
        dp = docproducer
        # Generate the score card.
        scheme = 'acceptance' if self.acceptance_report else 'qualification'
        dp.add_heading('chapter', 'CBF %s Summary' % scheme.capitalize(),
                       anchor=True)
        dp.add_include('summary_info.inc')
        reqs = self.grouped_requirements(self.status_of_requirements)
        header = ["label", "FAILED", "PASSED",
                  "SKIPPED", "TBD", 'WAIVED', "UNKNOWN", "total"]
        table = []
        for ts in nsort(reqs):
            for desc in nsort([t for t in reqs[ts]
                               if t in ('VerificationRequirement',
                                        'TestProcedure')]):
                for demo_or_test in reversed(nsort(reqs[ts][desc])):
                    title = "cbf %s %s %s results" % (ts, scheme, demo_or_test)
                    label = dp.add_link(self.document_lookup.get(
                        title.lower(), title))
                    row_data = self.sum_status(reqs[ts][desc][demo_or_test])
                    row_data['FAILED'] = (row_data.get('FAILED', 0) +
                                          row_data.get('ERROR', 0))
                    if row_data['FAILED'] == 0:
                        row_data['FAILED'] = '--'
                    row_data['label'] = label
                    table.append(row_data)

        dp.add_table_ld(table, header_map=header,
                        table_title="Verification Requirements Results Table",
                        hide_first_header=True)

        #ADD SUMMARY OF QUALIFICATION/ACCEPTANCE TEST RESULTS AND DEMONSTRATION RESULTS
        timescales = dict([(n, []) for n in self.get_timescales()])
        for timescale in nsort(timescales.keys()):
            ts_string = " ".join([ts.capitalize() for ts in timescale.split(' ')])
            dp.add_heading('chapter', 'CBF %s %s Testing Results'
                        % (ts_string, scheme.capitalize()), anchor=True)
            dp.add_include('cbf_%s_%s_testing_results_summary.inc'
                        % (ts_string.lower().replace(' ','_'), scheme.lower()))
            dp.add_include('cbf_%s_%s_testing_results_table.inc'
                        % (ts_string.lower().replace(' ','_'), scheme.lower()))

            dp.add_heading('chapter', 'CBF %s %s Demonstration Results'
                        % (ts_string, scheme.capitalize()), anchor=True)
            dp.add_include('cbf_%s_%s_demonstration_results_summary.inc'
                        % (ts_string.lower().replace(' ','_'), scheme.lower()))
            dp.add_include('cbf_%s_%s_demonstration_results_table.inc'
                        % (ts_string.lower().replace(' ','_'), scheme.lower()))
        
    def write_report_system_info(self, base_dir):
        dp = self.docproducer
        self.clear()
        dp.add_heading('chapter', 'System Information', anchor=True)
        labels = self.system_data.get('Labels', {})
        for section_name in ['vcs_version']:

            section = self.system_data.get(section_name, {})
            label = labels.get(section_name,
                               {}).get('label', section_name.title())
            dp.add_heading('section', label)
            desc = labels.get(section_name, {}).get('description')
            if desc:
                dp.add_line(desc)

            if isinstance(section, dict):
                self._rst_add_data(dp, section)
            elif isinstance(section, list):
                for line in section:
                    dp.add_line(str(line))
            else:
                dp.add_line(str(section))

        filename = os.path.join(base_dir, 'system_info.rst')
        with open(filename, 'w') as fh:
            for line in dp.output:
                fh.write(line + "\n")

    def generate_include_documents(self, basedir):
        """Generate several documents that is included in other documents."""
        ACCEPT = 'acceptance'
        QUAL = 'qualification'
        self.base_dir = basedir
        reqs = self.grouped_requirements(self.status_of_requirements)
        for timescale, scheme in itertools.product(reqs, [QUAL, ACCEPT]):
            for vreq in [t for t in reqs[timescale]
                         if t in ('VerificationRequirement',
                                  'TestProcedure')]:
                for demo in reqs[timescale][vreq]:
                    is_demo = demo == 'Demonstration'
                    for result in ['Results', 'Procedure']:
                        if result == 'Procedure':
                            is_demo = True
                            # For procedures we want the same type
                            # of table and summary.
                        items = {}
                        for item in reqs[timescale][vreq][demo]:
                            if scheme == ACCEPT:
                                if not self.is_acceptance(item):
                                    # Skip if this is an acceptance report and
                                    # the requirements do not have a test
                                    # flagged as acceptance.
                                    continue
                            if not (item.startswith('TP.C.') or
                                    item.startswith('R.C.')):
                                continue

                            items[item] = \
                                self.status_of_requirements(item, is_demo)
                            if result == 'Results' and items[item] == 'Exists':
                                items[item] = 'PASSED / FAILED'

                        title = "CBF %s %s %s %s Summary" % \
                                (timescale, scheme, demo, result)
                        self.generate_include_summary(title, items, basedir)
                        title = "CBF %s %s %s %s" % \
                                (timescale, scheme, demo, result)
                        self.generate_include_table(title, items, basedir)

    def is_acceptance(self, req_name):
        """Check if a requirement is linked to an acceptance test."""
        requirements = self._requirements_from_tests()
        requirement = requirements.get(req_name, {})
        tests = requirement.get('tests', [])
        for test in tests:
            acceptance = self.test_data[test].get('aqf_site_acceptance', False)
            if acceptance:
                return True

    def generate_include_summary(self, title, items, basedir):
        # Generate the Summary.
        self.clear()
        filename = title.lower().replace(" ", "_") + ".inc"
        sum_data = {}
        for item in items:
            status = items[item]
            sum_data[status] = sum_data.get(status, 0) + 1
        self.add_styled_summary(sum_data)
        with open(os.path.join(basedir, filename), 'w') as fh:
            for line in self.docproducer.output:
                fh.write(line + '\n')

    def short_link(self, text, post_text=None):
        """Generate a shorted link to documents."""
        text = str(text).lower()
        ref = str(zlib.adler32(text) & 0xffffffff)
        if post_text:
            ref = ref + "_" + str(post_text).lower()
        return ref

    def generate_include_table(self, title, items, basedir):
        ## Generate the table.
        self.clear()
        filename = title.lower().replace(" ", "_") + "_table.inc"
        table_data = []
        header_map = []
        if title.lower().endswith('procedure'):
            header_map.append('requirement')
        header_map.extend(['verification requirement',
                           'status', 'description'])
        for req in nsort(items):
            vr = self.requirements.get(req, {})
            row = {'verification requirement': self.docproducer.add_link(
                self.short_link(title, req), req)}
            row['status'] = self.docproducer.str_style(items[req])
            row['description'] = vr.get('name', '')
            if title.lower().endswith('procedure'):
                row['requirement'] = " ".join(nsort(vr.get('relationship', {}).
                                              get('verifies', [])))

            table_data.append(row)
        self.docproducer.add_table_ld(table_data,
                                      table_title=title.title(),
                                      header_map=header_map)
        with open(os.path.join(basedir, filename), 'w') as fh:
            for line in self.docproducer.output:
                fh.write(line + '\n')

    def add_styled_summary(self, data):
        dp = self.docproducer
        total = 0
        for name in sorted(data):
            if data[name] > 0 and name != 'total':
                styled_no = dp.str_style(name.title(), data[name])
                dp.add_line(":%s: %s" % (name.title(), styled_no))
                total += data[name]

        dp.add_line(":Total: %s" % data.get('total', total))

    def _rst_requirement_list(self, docproducer):
        docproducer.add_heading('chapter', 'AQF Requirements List', True)
        requirements = self._requirements_from_tests()
        for req in nsort(requirements):
            self._rst_requirement(req, requirements[req])

    def _rst_requirement(self, name, data):
        """Add one requirement to the Report."""
        dp = self.docproducer
        core_req = {}
        if self.requirements.get(name):
            core_req = self.requirements.get(name)
        dp.add_anchor(name)
        dp.add_heading('subsection',
                       "%s: %s" % (name, core_req.get('name', '')))
        if not data.get('success'):
            dp.add_line("The requirement in " +
                        dp.str_style('red', 'NOT')
                        + " met")
        if self.requirements.get(name):
            dp.add_line("Procedure defined in %s" %
                        dp.add_link("procedure_%s" % name))
        disp_order = ['description', 'relationship', 'timescale']

        # Get information form the requirements doc.
        if core_req:
            self._rst_add_data(dp, core_req, disp_order)

        dp.add_line("The requirement status is %s" %
                    dp.str_style(data.get('status', self.UNKNOWN).upper()))
        for test in data.get('tests'):
            styled_status = dp.str_style(data['tests'][test].get(
                'status', self.UNKNOWN).upper())
            dp.add_line(" * %s status is %s" %
                        (dp.add_link(test), styled_status))

    def add_requirement(self, name, fields=None, data=None,
                        title=None, number=None):
        """Add this requirement to the report."""
        dp = self.docproducer
        req_data = {}
        req_data.update(self.requirements.get(name))
        if data:
            req_data.update(data)
        if title:
            dp.add_anchor(self.short_link(title, name))
        else:
            dp.add_anchor(name)
        long_name = req_data.get('name', name)
        stitle = name if name == long_name else "%s: %s" % (name, long_name)
        if number:
            dp.add_heading('section', number + ' - ' + stitle)
        else:
            dp.add_heading('section', stitle)
        self._rst_add_data(dp, req_data, fields, ['id'])
        relationship = req_data.get('relationship', {})
        relationships = []
        for rtype in ('verifies', 'X-referenced by', 'X-references',
                      'referenced by', 'references'):
            for r in  relationship.get(rtype, []):
                if r.startswith('R.C.'):
                    relationships.append(r)

        dp.add_heading('subsection', 'Requirements Verified')
        if relationships:
            for rel in nsort(relationships):
                dp.add_line(":{0}: {1}".
                            format(rel, self.requirements.get(rel, {}).
                                get('description', '')))
        else:
            dp.add_line("No Requirements")

    def _rst_procedure(self, docproducer, verification_requirement=True):
        """Generate a test procedure document.

        The test procedure document will explain how each VR was tested.

        """

        test_requirements = self._requirements_from_tests()
        if verification_requirement:
            docproducer.add_heading('chapter', "AQF Test Procedure")
            list_of_requirements = self.requirements
        else:
            docproducer.add_heading('chapter',
                                    "AQF Test Procedure(exclude VR)")
            list_of_requirements = test_requirements

        for vr in nsort(list_of_requirements):
            _req = self.requirements.get(vr, {})
            if verification_requirement:
                condition = _req.get("definition") in ("VerificationRequirement",
                                                       'TestProcedure')
            else:
                condition = _req.get("definition") not in (
                    "VerificationRequirement", 'TestProcedure')

            # if (condition and ("1500 CAM" in _req.get('category-list', [])
            #                    or "1200 CBF" in requirement.get('category-list', []))):
            if True:
                docproducer.add_anchor("procedure_%s" % vr)
                docproducer.add_heading('section', "%s: %s" %
                                        (vr, self.requirements.get(
                                            vr, {}).get("name", '')))
                self._rst_add_data(docproducer, _req,
                                   ['description', 'timescale'])

                self._rst_add_data(docproducer,
                                   {"Last run": docproducer.add_link(vr),
                                    "CORE definition":
                                    docproducer.add_link("core_%s" % vr)
                                    })
                self.add_requirement_procedure(vr)

    def add_requirement_results(self, req_id):
        """Add to the report the test procedures for the requirements."""
        tests = self._requirements_from_tests().get(req_id, {}).get('tests')
        self.docproducer.add_heading('subsection', 'Results')
        if tests:
            for test in nsort(tests):
                self._rst_show_test(self.docproducer, 1,
                                    test, self.test_data[test])
        else:
            self.docproducer.add_line("No Result")

    def add_requirement_procedure(self, req_id, demo_script=[]):
        """Add to the report the test procedures for the requirements."""
        tests = self._requirements_from_tests().get(req_id, {}).get('tests')
        self.docproducer.add_heading('subsection', 'Method')
        if tests:
            for test in nsort(tests):
                demo_script.append(('test', test))
                self.add_test_procedure(test, demo_script)
        else:
            self.docproducer.add_line("No Procedure Implemented")

    def add_test_procedure(self, test_id, demo_script=[]):
        """Add to the report the procedure for the test."""
        dp = self.docproducer
        dp.add_line("* Test - %s\n\n  %s" %
                    (dp.add_link(test_id),
                     self.test_data[test_id].get('description', '')))
        steps = self.test_data.get(test_id, {}).get('steps', {})
        counter = 0
        for step in nsort([s for s in steps if not steps[s].get('hop')]):
            counter += 1
            this_step = self.test_data[test_id]['steps'][step]
            dp.add_line(" - Step %d: %s" %
                        (counter, this_step.get('description', '')))
            demo_script.append(('step', counter))

            for action in [a for a in this_step.get('action', [])
                           if a.get('type') in ['checkbox',
                                                'waived',
                                                'evaluate']]:
                if action.get('type') == 'checkbox':
                    demo_script.append(('checkbox',
                                        {'msg': action.get('msg')}))
                    dp.add_line('  + %s: %s \n      **PASSED / FAILED** ' %
                                (action.get('type', '').title(),
                                 action.get('msg')))
                else:
                    dp.add_line('  + %s: %s' % (action.get('type', '').title(),
                                                action.get('msg')))

    def _rst_timescale(self, docproducer, timescales=None):
        """Create a report for a timescale."""
        docproducer.add_heading('chapter', "Timescale Report")
        test_requirements = self._requirements_from_tests()
        cbf_timescale = 'Timescale Unlinked'
        if not timescales:
            timescales = dict([(n, []) for n in self.get_timescales()])
            timescales[cbf_timescale] = []
        elif not isinstance(timescales, list):
            timescales = {timescales: []}
        table_head = ['VR', 'Status', 'Description']
        for req_id in self.requirements:
            req = self.requirements[req_id]
            if (req.get("definition") in ("VerificationRequirement",
                                          'TestProcedure')
                # and ("1500 CAM" in req.get('category-list', []) or
                #      "1200 CBF" in req.get('category-list', []))
            ):
                req_timescale = req.get('timescale', cbf_timescale)
                if timescales.get(req_timescale) is not None:
                    timescales[req_timescale].append(req_id)

        if cbf_timescale in timescales:
            for req in test_requirements:
                if req not in self.requirements:
                    timescales[cbf_timescale].append(req)
        ######################
        for timescale in nsort(timescales.keys()):
            counter = {'error': 0, 'failed': 0, 'passed': 0}
            docproducer.add_anchor(timescale)
            docproducer.add_heading('section', timescale)
            sorted_table_data = []
            for vr in nsort(timescales[timescale]):
                status = test_requirements.get(vr, {}).get('status',
                                                           self.UNKNOWN)
                counter[status] = counter.get(status, 1) + 1
                row = [docproducer.add_link(vr, vr),
                       docproducer.str_style(status.upper()),
                       self.requirements.get(vr, {}).get('name', '')]
                sorted_table_data.append(row)
            self.add_styled_summary(counter)
            docproducer.add_table(table_head, sorted_table_data)

    def _rst_system(self, docproducer, filter_name=None):
        # Create includes.
        if (isinstance(self.system_data, str) and
                os.path.isfile(self.system_data)):
            # Received a filename not the data.
            docproducer.add_line('Read data from file: %s' % self.system_data)
            with open(self.system_data, 'r') as fh:
                data = json.loads(fh.read())
            if data:
                self.system_data = data
        labels = self.system_data.get('Labels', {})
        inc_files = []
        section_names = [n for n in self.system_data.keys()
                         if n not in ['Labels']]
        for section_name in section_names:
            self.clear()
            docproducer = self.docproducer
            section = self.system_data.get(section_name, {})
            label = labels.get(section_name,
                               {}).get('label', section_name.title())
            docproducer.add_heading('section', label)
            desc = labels.get(section_name, {}).get('description')
            if desc:
                docproducer.add_line(desc)

            if isinstance(section, dict):
                self._rst_add_data(docproducer, section)
            elif isinstance(section, list):
                for line in section:
                    docproducer.add_line(str(line))
            else:
                docproducer.add_line(str(section))

            filename = "sysinfo_%s.inc" % section_name
            inc_files.append(filename)
            with open(os.path.join(self.base_dir, filename), 'w') as fh:
                for line in self.docproducer.output:
                    fh.write(line + '\n')

        # Create the doc.
        self.clear()
        docproducer = self.docproducer
        nose_cmd = " ".join(self.test_data.get("Meta", {}).get("sys_args", []))
        docproducer.add_heading('chapter', 'Detailed System Information')
        docproducer.add_line('The following information was captured on the '
                             'system before the tests ran.')
        data = {}
        if not self.system_data:
            self.system_data = 'katreport/katreport_system.json'

        docproducer.add_line("Nose Called with:")
        docproducer.add_sourcecode(nose_cmd)

        if not isinstance(self.system_data, dict):
            self.system_data = {}

        for filename in inc_files:
            docproducer.add_include(filename)

    def _rst_table(self, docproducer, filter_name=None):
        """Generate a report of tests against requirements in a table."""
        requirements = self._requirements_from_tests()
        table_head = ['Status', 'Requirement', 'Description']
        table_data = {}
        heading_title = "AQF Table"
        requirement_keys = []
        if filter_name == "vr":
            heading_title = "AQF Verification Requirements Table"
            for key in nsort(requirements.keys()):
                if (self.requirements.get(key, {}).get("definition") in
                        ("VerificationRequirement", 'TestProcedure')):
                    requirement_keys.append(key)
        elif filter_name == "not_vr":
            heading_title = "AQF Requirements Table (excluding VR)"
            for key in nsort(requirements.keys()):
                if not (self.requirements.get(key, {}).get("definition") in
                        ("VerificationRequirement", 'TestProcedure')):
                    requirement_keys.append(key)
        else:
            requirement_keys = nsort(requirements.keys())

        ## Draw a table for all the elements in requirement_keys
        for req in requirement_keys:
            status = requirements[req].get('status').upper()
            req_data = [docproducer.str_style(status),
                        docproducer.add_link(req, req),
                        self.requirements.get(req, {}).get('name', '')]
            if status not in table_data:
                table_data[status] = []
            table_data[status].append(req_data)

        docproducer.add_heading('chapter', heading_title)
        sorted_table_data = []
        for status in sorted(table_data, self._sort_comp_status):
            for row in table_data[status]:
                sorted_table_data.append(row)
        docproducer.add_table(table_head, sorted_table_data)

    def _rst_add_data(self, docproducer, data,
                      add_items=None, ignore_items=None):
        """ ."""

        if not add_items:
            add_items = sorted(data.keys())
        elif not isinstance(add_items, list):
            add_items = [add_items]

        if not isinstance(ignore_items, list):
            ignore_items = []

        for item in [i for i in add_items if i not in ignore_items]:
            title_str = item
            data_str = ''
            if data.get(item):
                if item == 'timescale':
                    data_str = docproducer.add_link(data[item])
                elif item == 'relationship':
                    tmp_str = ''
                    for rel in sorted(data[item].keys()):
                        tmp_str = tmp_str + ("%s: %s;  " % (rel.title(),
                             " , ".join([docproducer.add_link("core_%s" % n, n)
                                         for n in nsort(data[item][rel])])))
                    data_str = tmp_str.strip().strip(";")
                elif item == 'requirements':
                    tmp_str = "\n    * ".join([docproducer.add_link(n)
                                               for n in data[item]])
                    data_str = " * " + tmp_str
                elif item == 'group':
                    title_str = 'Test Group'
                elif item == 'category-list':
                    title_str = 'category'
                    data_str = '>'.join(data[item])
                else:
                    data_str = docproducer.clean_text_block(unicode(data[item]))
            if title_str and data_str:
                docproducer.add_line(":%s: %s" % (title_str.title(), data_str))

    def _rst_core(self, docproducer):
        """Generate a report of the entities from Core."""
        definitions = {}
        for item in self.requirements: # [d for d in self.requirements
            if not (item.startswith('TP.C') or
                    item.startswith('VR.C') or
                    item.startswith('R.C')):
                continue

            req_def = self.requirements[item].get('definition', self.UNKNOWN)
            if req_def not in definitions:
                definitions[req_def] = []
            definitions[req_def].append(item)
        docproducer.add_heading('chapter', "CORE Entities")
        docproducer.add_line(':Exported: %s' % (self.core_meta.get(
            'export', {}).get('time-stamp', '')))
        docproducer.add_line(':Processed: %s' % (self.core_meta.get(
            'processed', {}).get('time', '')))

        for definition in sorted(definitions):
            docproducer.add_heading('section', definition)
            for entity in nsort(set(definitions[definition])):
                docproducer.add_anchor("core_%s" % entity)
                desc = self.requirements[entity].get('name', '')
                if entity == desc:
                    heading = "%s" % entity
                else:
                    heading = "%s: %s" % (entity, desc)

                docproducer.add_heading('subsection', heading)
                data = {}
                data.update(self.requirements[entity])
                data["Last run"] = docproducer.add_link(entity)
                data["Test procedure"] = docproducer.add_link("procedure_%s"
                                                              % entity)
                self._rst_add_data(docproducer, data, None,
                                   ['kat_id', 'definition', 'name', 'id',
                                    'tag', 'depth', 'collection-attribute'])

    def _rst_tests(self, docproducer):
        """Generate a report that lists all the tests."""
        docproducer.add_heading('chapter', 'AQF Tests Report')
        for test in sorted(self.test_data.keys()):
            self._rst_show_test(docproducer, 1,
                                test, self.test_data[test])

    def _rst_show_test(self, docproducer, level, test_name, test_data):
        """Add a summary of a test to the docproducer."""
        if test_name == "Meta":
            return
        docproducer.add_anchor(test_name)
        docproducer.add_heading('subsubsection',
                                test_data.get('label', test_name))

        test_path = test_name.split(".")
        testfile = "{0}.py:{1}.{2}".format('/'.join(test_path[:-2]),
                                           test_path[-2], test_path[-1])
        docproducer.add_sourcecode(testfile)
        data = {'description': test_data.get('description'),
                'group': test_data.get('group', 'Unknown')}
                #'status': docproducer.str_style(
                #    test_data.get('status', self.UNKNOWN).upper())}

        #if not test_data.get('success'):
        #    docproducer.add_box_warning(test_data.get('status',
        #                                             # self.UNKNOWN).title())
        ## AQF decorator info.
        data['systems'] = ", ".join([n for n in
                                     test_data.get('aqf_systems', [])])

        aqf_vars = {'aqf_site_acceptance': "This test Is part of the *Site"
                                           " Acceptance* tests",
                    'aqf_intrusive': "This test has been tagged as an"
                                     " intrusive test.",
                    'aqf_slow': "This test has been tagged as a slow test",
                    'aqf_site_only': "This should run on *Site Only*",
                    'aqf_site_test': "This is a SITE test",
                    'aqf_demo_test': "This is a DEMO test",
                    'aqf_auto_tests': "This is an AUTO test"}

        for aqf_var in aqf_vars:
            if test_data.get(aqf_var):
                data[aqf_var.replace('aqf_', '').replace('_', ' ')
                     ] = aqf_vars[aqf_var]

        data['requirements'] = test_data.get('requirements', [])
        self._rst_add_data(docproducer, data)

        ## Show the steps:
        counter = 0
        for step in nsort(test_data.get('steps', {}).keys()):
            this_step = test_data['steps'][step]
            if this_step.get('hop'):
                docproducer.add_line("- Hop: %s (%s)" %
                                    (this_step.get('description'), this_step.get('step_start')))
            else:
                counter += 1
                docproducer.add_line("- Step %d: %s (%s)" %
                                    (counter, this_step.get('description'), this_step.get('step_start')))
            ## Show the progress:
            for action in this_step.get('action', []):
                line = [" +"]
                line.append(action.get('time', ''))
                action_type = action.get('type', '').upper()
                line.append(docproducer.str_style(action_type))
                line.append(action.get('msg', ''))
                # Do not write out the "CONTROL start" and "CONTROL end" lines
                if action_type != 'CONTROL':
                    docproducer.add_line("  ".join([l for l in line if l]))
                if action_type == 'CHECKBOX':
                    docproducer.add_line('        **PASSED / FAILED** ')
                if action.get('stack'):
                    docproducer.add_sourcecode(''.join(action['stack']))
                if action_type == 'IMAGE':
                    docproducer.add_figure(
                        action['filename'], action['caption'], action['alt'])

        if not test_data.get('success'):
            docproducer.add_sourcecode(
                test_data.get('error_msg', '').strip())

    def _comp_status(self, status1, status2):
        """Compare the severity of test statuses.

        :return: The highest ranked status is returned.

        """
        status1 = str(status1).lower()
        status2 = str(status2).lower()
        # * Rolled up VR status of PASS/ SKIPPED /WAIVED must be checked: order
        # is FAIL/ERROR, TBD, SKIPPED, PASSED, WAIVED (Thus anything for which one
        # step SKIP while rest PASSED results in SKIP, anything of which all is
        # PASSED but one is WAIVED results in WAIVED)
        status = [self.UNKNOWN,   # Dont know what happened
                  self.WAIVED,    # Test is waived
                  self.PASS,      # Test Passed
                  self.SKIP,      # Skip this test
                  self.TBD,       # Test is to-be-done
                  self.FAIL,      # Test Failed
                  self.ERROR]     # Something went wrong
        try:
            pos1 = status.index(status1)
        except ValueError:
            pos1 = status.index(self.UNKNOWN)

        try:
            pos2 = status.index(status2)
        except ValueError:
            pos2 = status.index(self.UNKNOWN)

        if pos1 > pos2:
            return status1
        else:
            return status2

    def _sort_comp_status(self, status1, status2):
        """Compare the severity of test statuses.

        :return: Int. 1 or -1 Used for sorted operation.

        """
        status = self._comp_status(status1, status2)
        if status == status1.lower():
            return -1
        else:
            return 1

    def _requirements_from_tests(self):
        """Do a Requirements analysis.

        :return: Dict. Requirement is the key.

        """

        if not self._cache_requirements_from_tests:
            reqs = dict()
            for test in self.test_data:
                if test == "Meta":
                    continue
                test_data = {'status': self.test_data[test].get('status',
                                                                self.UNKNOWN),
                             'success': self.test_data[test].get('success',
                                                                 False)}
                for test_req in self.test_data[test].get('requirements', []):
                    if test_req not in reqs:
                        reqs[test_req] = {'status': self.UNKNOWN,
                                          'success': True,
                                          'tests': {}}
                    reqs[test_req]['tests'][test] = test_data
                    reqs[test_req]['success'] &= test_data['success']
                    reqs[test_req]['status'] = self._comp_status(
                        reqs[test_req]['status'],
                        test_data['status'])

            self._cache_requirements_from_tests = reqs
        return self._cache_requirements_from_tests


def _sortkey_natural(s):
    """Asist function for sorted to make the sorts a bit more natural.

    eg. sorted(data.keys(), key=_sortkey_natural)
    :return: Tuple. The search keys of a value.

    """
    return tuple(int(part) if re.match(r'[0-9]+$', part) else part
                 for part in re.split(r'([0-9]+)', str(s)))


def nsort(data):
    """Natural sort.

    :return: List. Sorted values.

    """
    if data is None:
        return []
    return sorted(data, key=_sortkey_natural)
#
